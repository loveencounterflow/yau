// Generated by CoffeeScript 2.0.3
(function() {
  'use strict';
  /* https://github.com/sindresorhus/emittery */
  var CND, Emittery, HSB, XMT, after, alert, also_on, badge, crash, debug, defer, delegate, emit, error_handler, happy, help, info, is_crash, is_happy, is_sad, is_unhappy, jr, new_defect, new_failure, primary_on, promisify, require_xemitter, rpr, sad, select, urge, use_sample_delegator_A, use_sample_delegator_B, warn, whisper;

  /* https://ponyfoo.com/articles/understanding-javascript-async-await */
  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'AWAIT-PROMISES2';

  debug = CND.get_logger('debug', badge);

  alert = CND.get_logger('alert', badge);

  whisper = CND.get_logger('whisper', badge);

  warn = CND.get_logger('warn', badge);

  help = CND.get_logger('help', badge);

  urge = CND.get_logger('urge', badge);

  info = CND.get_logger('info', badge);

  HSB = require('/home/flow/io/kleinbild-rack/kbm/lib/happy-sad-bad');

  ({happy, sad, is_sad, new_defect, new_failure, is_crash, crash, is_unhappy, is_happy} = HSB);

  ({
    after,
    immediately: defer
  } = CND.suspend);

  ({promisify} = require('util'));

  jr = JSON.stringify;

  Emittery = require('emittery');

  //===========================================================================================================
  require_xemitter = function() {
    var L, name, ref, results, value;
    /*

    xemitter uses `sindresorhus/emittery` to provide an event emitter and task delegation facility that
    simplifies building asynchronous applications using the Actor pattern.

    Events are pairs of channel names and arbitrary data items. Events are emitted by emitter functions.

    An arbitrary number of listeners can listen on any given channel. Listeners may be synchronous (returning
    anything but a promise) or asynchronous (returning a promise). Each listener produces a value, be it
    implicitly (`undefined`) or explicitly (by using `return x` or `resolve x`). The outcomes of all listeners
    are collected into an array of values, which may or may not be consumed by emitters.

    Delegators are (inherently asynchronous) emitter functions that not only emit events, but that also use
    the result(s) that the event listener(s), if any, produced.

    Because of the inherent unpredictability of the asynchronous mode of operation, no guarantee is made about
    the ordering of values in the event result array. Since an important use case for event emitting is task
    delegation, there is a way to distinguish a primary result from spurious and secondary results: On the one
    hand, up to one listener may bind to a channel using `XMT.primary_on`. Whatever values(s) that listener
    produces when answering an event will be wrapped into a nonce object. The delegator then uses `await
    XMT.delegate` or `XMT.select await XMT.emit` to retrieve up to one primary item from the event results:

    ```
     * define a function that delegates some task:
    sample_delegator = ->
      result = await delegate 'some_task', 42
      if is_sad result
        ... sad path ...
      else
        ... happy path ...
        return some_value

     * use the delegator:
    sample_delegator()
      .then ( x ) ->
        return error_handler x if is_sad x
     * xxx
        help 'resolved', jr x
      .catch error_handler
    ```

     */
    //-----------------------------------------------------------------------------------------------------------
    this._emitter = new Emittery();
    this._has_primary_listeners = {};
    //-----------------------------------------------------------------------------------------------------------
    this._mark_as_primary = function(x) {
      return {
        '~isa': 'XEMITTER/preferred',
        value: x
      };
    };
    //-----------------------------------------------------------------------------------------------------------
    this.select = function(values) {
      var ref, ref1;
      return (ref = (ref1 = (values.filter(function(x) {
        return CND.isa(x, 'XEMITTER/preferred');
      }))[0]) != null ? ref1.value : void 0) != null ? ref : null;
    };
    //-----------------------------------------------------------------------------------------------------------
    this.primary_on = function(channel, listener) {
      if (this._has_primary_listeners[channel]) {
        throw new Error(`channel ${rpr(channel)} already has a primary listener`);
      }
      this._has_primary_listeners[channel] = true;
      return this._emitter.on(channel, async(data) => {
        return this._mark_as_primary((await listener(data)));
      });
    };
    //-----------------------------------------------------------------------------------------------------------
    this.also_on = function(channel, listener) {
      return this._emitter.on(channel, listener);
    };
    //-----------------------------------------------------------------------------------------------------------
    this.emit = function(channel, data) {
      return this._emitter.emit(channel, data);
    };
    this.delegate = async function(channel, data) {
      return this.select((await this._emitter.emit(channel, data)));
    };
    ref = L = this;
    // debug '22621', Object::toString.call @delegate

    //###########################################################################################################
    results = [];
    for (name in ref) {
      value = ref[name];
      if (!CND.isa_function(value.bind)) {
        /* TAINT poor man's 'callable' detection */
        continue;
      }
      results.push(L[name] = value.bind(L));
    }
    return results;
  };

  //###########################################################################################################
  require_xemitter.apply(XMT = {});

  ({select, emit, delegate, also_on, primary_on} = XMT);

  //-----------------------------------------------------------------------------------------------------------
  error_handler = function(reason) {
    if (is_sad(reason)) {
      return urge('this is sad:', jr(reason));
    }
    if (is_crash(reason)) {
      warn(CND.reverse('bad'));
      warn('this is a crash');
      warn(jr(reason));
      process.exit(1);
    }
    // don't throw new Error( reason );
    // throw reason
    alert(CND.reverse('evil'));
    alert(reason);
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  also_on('some_task_A', function(data) {
    debug('on some_task_A', jr(data));
    return 'a secondary result';
  });

  //-----------------------------------------------------------------------------------------------------------
  also_on('some_task_B', function(data) {
    debug('on some_task_B', jr(data));
    return 'a secondary result';
  });

  //===========================================================================================================
  use_sample_delegator_A = function() {
    var sample_delegator_A;
    //-----------------------------------------------------------------------------------------------------------
    primary_on('some_task_A', function(data) {
      debug('on some_task_A', jr(data));
      return new Promise(function(pass, toss) {
        if (Math.random() > 0.5) {
          pass("a happy primary result");
        } else {
          pass(new_failure('code42', "a sad primary result"));
        }
        return null;
      });
    });
    //-----------------------------------------------------------------------------------------------------------
    sample_delegator_A = async function() {
      var result;
      result = (await delegate('some_task_A', 42));
      // result = select await emit 'some_task_A', 42
      if (is_sad(result)) {
        urge('sample_delegator_A sad result:    ', jr(result));
        return null;
      } else {
        help('sample_delegator_A happy result:  ', jr(result));
        return `**${result}**`;
      }
    };
    //-----------------------------------------------------------------------------------------------------------
    return sample_delegator_A().then(function(x) {
      if (is_sad(x)) {
        return error_handler(x);
      }
      // xxx
      return help('resolved', jr(x));
    }).catch(error_handler);
  };

  //===========================================================================================================
  use_sample_delegator_B = function(settings) {
    var sample_delegator_B;
    //===========================================================================================================
    /* Synchronous contractors without promises and asynchronous contractors with promises show the same
    behavior; crucially, **the delegator does not have to be aware of any difference between the two**: */
    if (settings.use_promises_in_contractor) {
      info("using contractor with promises");
      //-----------------------------------------------------------------------------------------------------------
      primary_on('some_task_B', function(data) {
        debug('on some_task_B', jr(data));
        return new Promise(function(resolve, reject) {
          var a, b;
          [a, b] = data;
          if (b === 0) {
            return reject(new_failure('divbyzero', `division by zero: ${rpr(a)} / ${rpr(b)}`, null));
          }
          return resolve(a / b);
        });
      });
    } else {
      info("using contractor *without* promises");
      //-----------------------------------------------------------------------------------------------------------
      primary_on('some_task_B', function(data) {
        var a, b;
        debug('on some_task_B', jr(data));
        [a, b] = data;
        if (b === 0) {
          throw new_failure('divbyzero', `division by zero: ${rpr(a)} / ${rpr(b)}`, null);
        }
        return a / b;
      });
    }
    //-----------------------------------------------------------------------------------------------------------
    sample_delegator_B = async function() {
      var result_1, result_2, unhappy;
      try {
        //.......................................................................................................
        info("computing 4 / 5");
        result_1 = (await delegate('some_task_B', [4, 5]));
        info(`computing 4 / 5: ${result_1}`);
        //.......................................................................................................
        info("computing 3 / 0");
        result_2 = (await delegate('some_task_B', [3, 0]));
        info(`computing 3 / 0: ${result_2}`);
        //.......................................................................................................
        // In the case of a style B contractor, only happy results are resolved; sad and bad results are
        // rejected and end up in the catch clause:
        return [result_1, result_2];
      } catch (error) {
        unhappy = error;
        warn('28921', unhappy);
        if (is_sad(unhappy)) {
          // deal with failures: possibly log where and what occurred, return a replacement value (that may in
          // itself by happy or sad):
          result_2 = happy(unhappy);
          urge(`computing 3 / 0: ${result_2}`);
          urge('sample_delegator_B sad result:    ', jr(unhappy));
          return null;
        }
        // refuse to deal with anything else:
        throw unhappy;
      }
    };
    //-----------------------------------------------------------------------------------------------------------
    return sample_delegator_B().then(function(x) {
      if (is_sad(x)) {
        return error_handler(x);
      }
      // xxx
      return help('resolved', jr(x));
    }).catch(error_handler);
  };

  //###########################################################################################################
  if (module.parent == null) {
    // use_sample_delegator_A()
    use_sample_delegator_B({
      use_promises_in_contractor: true
    });
  }

  // use_sample_delegator_B { use_promises_in_contractor: no, }

}).call(this);

//# sourceMappingURL=demo.js.map
